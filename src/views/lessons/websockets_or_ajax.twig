{% set title = 'WebSockets или AJAX' %}

{% extends "../layouts/app.twig" %}

{% block content %}
    <img src="https://miro.medium.com/max/2400/1*26Dlo1s4BphkWhD0ut_Low.jpeg" alt="" style="width: 100%">
    <h1 class="mt-4">{{ title }}.</h1>

    <p>Это не учебник. В этой статье рассказывается о достижениях в динамической веб-разработке и о том, как мы можем улучшить динамический характер наших веб-приложений.
    </p><p>Итак, до сих пор Интернет представлял собой набор статических HTML-страниц. Отправьте запрос на страницу, подождите, получите контент страницы - контент, уже набранный вручную веб-разработчиком. Старые добрые дни.</p>
    <p>Вскоре потребность в динамических страницах стала очевидной (интересно, почему), и разработчики искали способ динамически контролировать конечный контент, отображаемый для клиента (которым является веб-браузер).</p>
    <p> не буду утомлять вас технической историей здесь, но вы можете вывести график событий, ведущих к развитию языков сценариев серверов, которые у нас есть сейчас. Теперь браузеры могут отправлять запросы с определенными параметрами запроса, которые будут приниматься сервером, выполняя указанный запрос и генерируя контент, уникальный для этого запроса.</p>
    <p>Однако этого было недостаточно. Необходимо было сделать еще один шаг вперед: обновить содержимое уже загруженной веб-страницы. Лучший способ добиться этого - выяснить, как установить постоянное соединение между веб-браузером и сервером, позволяющее обмениваться данными через четко определенный протокол (например, HTTP).</p>
    <p>Microsoft представила XMLHttpRequest, который сформирует базовую основу AJAX (асинхронный Javascript и XML), что приведет нас в эру клиентских запросов без необходимости перезагрузки (асинхронные запросы). Имя XMLHttpRequest теперь немного вводит в заблуждение, потому что HTTP - это всего лишь один из различных протоколов, которые можно использовать, и данные могут быть получены с помощью различных форм, таких как текст, HTML или JSON, а не только XML.</p>
    <p>Базовым показателем для объекта XMLHttpRequest, более эффективных методов (таких как Fetch API на основе обещаний) является использование REST API (API передачи репрезентативного состояния), которое в лучшем случае было односторонним, основанным на CRUD, протокол без состояния. (Односторонний - вы можете только отправлять запросы на сервер и получать ответ; на основе CRUD - вы в основном можете выполнять функции Create-Retrieve-Update-Delete; протокол без сохранения состояния - клиенту не нужно знать, что в настоящее время происходит на стороне сервера и наоборот - серверы традиционно «запоминают данные клиента» через файлы cookie).</p>
    <p>Этот традиционный REST API - протокол без сохранения состояния идеален - пока ваше приложение не требует постоянного обмена данными сервер-клиент.</p>
    <p>Пример приложений с постоянным обменом данными сервер-клиент:
    <ul>
        <li>Системы уведомлений</li>
        <li>Графики в реальном времени (статистика, модели валют и акций)</li>
        <li>Карты и трекеры местоположения</li>
        <li>Системы чата / обмена сообщениями</li>
        <li>Прямая трансляция видео</li>
    </ul></p>
    <p>Когда запрос протокола высокого уровня выполняется асинхронно (например, CRUD), между сервером и клиентом устанавливается соединение, и это соединение недолговечно. Он существует только для этого запроса, и после его завершения (возвращается код состояния, может быть 200, 403, 201 - что угодно) соединение разрывается. Это означает, что если вам нужна система уведомлений, вы бы продолжали отправлять запросы асинхронно, возможно, с помощью метода setInterval () Javascript, надеясь, что будет ответ, который будет служить уведомлением для конечного пользователя. Есть много причин, по которым такая практика неэффективна, но мы будем придерживаться характеристики такого метода с высокой задержкой. Эта характеристика проявляется в задержке при извлечении информации, которая может накапливаться со временем и, вероятно, приводит к большим временным промежуткам. Для справки геймеры называют это явление лагом.</p>
    <p>С WebSockets у вас есть операции с малой задержкой (быстрые), и большинство проблем, связанных с запросом на основе REST, решены. Вы можете увидеть полную разницу между запросом REST API и запросами WebSockets здесь.</p>
    <p>WebSockets создают долговременное соединение сервер-клиент на основе TCP (протокол управления передачей) и действительно двустороннее, с отслеживанием состояния и быстрее. Это делает его высокоэффективной альтернативой традиционным асинхронным HTTP-запросам, которые нам обычно удобны. Это лучший вариант для создания систем реального времени.
    <h3>PHP и веб-сокеты</h3>
    </p><p>PHP не имеет встроенной поддержки WebSockets. WebSockets был создан для работы с постоянными соединениями, чего нет на большинстве серверов PHP. Как и ожидалось, есть много способов обойти это.</p>
    <p>Некоторые сторонние пакеты могут помочь при взаимодействии с WebSockets. Один из ярких примеров - Pusher. Еще есть Рэтчет. Эти инструменты могут помочь вам установить постоянные соединения для облегчения обмена данными между сервером и клиентом и упростить современную динамическую разработку на PHP.</p>
    <p>Как упоминалось ранее, это не руководство по реализации API WebSocket в PHP. Из-за (текущего) отсутствия встроенной поддержки в PHP вам нужно будет изучить определенные методы у разных поставщиков пакетов.</p>
    <a href="https://blog.usejournal.com/websockets-or-rest-apis-modern-php-development-4998d5d102ad" target="_blank">Оригинал</a>
{% endblock %}
